/****************************************************************************\
 *           Copyright (C) 2012 Texas Instruments Incorporated.             *
 *                           All Rights Reserved                            *
 *                                                                          *
 * GENERAL DISCLAIMER                                                       *
 * ------------------                                                       *
 * All software and related documentation is provided "AS IS" and without   *
 * warranty or support of any kind and Texas Instruments expressly disclaims*
 * all other warranties, express or implied, including, but not limited to, *
 * the implied warranties of merchantability and fitness for a particular   *
 * purpose.  Under no circumstances shall Texas Instruments be liable for   *
 * any incidental, special or consequential damages that result from the    *
 * use or inability to use the software or related documentation, even if   *
 * Texas Instruments has been advised of the liability.                     *
 ****************************************************************************
This example shows three main features of Timers on KeyStone DSP:
1. generate one-shot pulse and interrupt
2. generate continual clock and interrupts
3. generate continual square waves and interrupts
4. watch-dog
 ****************************************************************************
 * Created by :                                                             *
 *            Brighton Feng                                                 *
 *            Texas Instruments                                             * 
 *            March 5, 2012                                                 *
 * Updated by Brighton Feng on Jun 25, 2014, add test case to generate 
                                        square waves with timer + EDMA      *
***************************************************************************/
#include <c6x.h>
#include <stdio.h>
#include <csl_bootcfgAux.h>
#include <csl_edma3.h>
#include "KeyStone_common.h"

/*delay (in millisecond) before the timer generate one-shot pulse*/
#define PULSE_DELAY_MS 			2000
/*period (in millisecond) of the clock generated by timer*/
#define CLOCK_PERIOD_MS 		1
/*number of the clocks generated in this test*/
#define NUM_CLOCKS_GENERATED 	500

/*period (in millisecond) of the waveform generated by timer*/
#define WAVE_PERIOD_MS 		1
/*Duty cycle of the waveform (percentage of low period)*/
#define WAVE_LOW_PERCENT 		66
/*number of the waves generated in this test*/
#define NUM_WAVES_GENERATED 	500

/*period (in millisecond) of the watch-dog timer*/
#define WATCH_DOG_PERIOD_MS 	3000

/*since the timer runs at (DSP core clock)/6
the conversion between millisecond and timer PRD value is:
PRD = (xxx_MS/1000)*DSP_CLK_HZ/6
    = xxx_MS*(DSP_CLK_HZ/1000)/6*/
    
volatile Uint32 uiTick = 0;

void Timer_Interrupts_Init(void)
{
	gpCGEM_regs->INTMUX1 = 0;
	gpCGEM_regs->INTMUX2 = 0;
	//map local timer interrupt to INT14
#ifdef CSL_GEM_TINT4L
	gpCGEM_regs->INTMUX3 = (CSL_GEM_TINTLN<<CSL_CGEM_INTMUX3_INTSEL14_SHIFT)
		|(CSL_GEM_TINT4L<<CSL_CGEM_INTMUX3_INTSEL15_SHIFT);
#else
	gpCGEM_regs->INTMUX3 = (CSL_GEM_TINTLN<<CSL_CGEM_INTMUX3_INTSEL14_SHIFT)
		|(CSL_GEM_TINT8L<<CSL_CGEM_INTMUX3_INTSEL15_SHIFT);
#endif

	//enable INT14
	CPU_interrupt_enable((1<<14)|(1<<15));
}

//Interrupt service routine for timer
void interrupt Timer_ISR(void)
{
	uiTick++;
}

/*use local timer (==DNUM of a core) to generate a pulse on TIMO0,
a interrupt is generated as well*/
void generate_pulse_by_timer()
{
	Timer64_Config tmrCfg;
	
	puts("\na pulse will be generated on TIMO0...");

	uiTick = 0;

	//select output on TIMO0 from local timer.
	gpBootCfgRegs->TOUTSEL = (DNUM*2)<<CSL_BOOTCFG_TOUTSEL_TOUTSEL0_SHIFT;

	//configure the timer for one shot pulse
	tmrCfg.timer_num= DNUM;
	tmrCfg.timerMode= TIMER_ONE_SHOT_PULSE;
	tmrCfg.period= (unsigned long long)PULSE_DELAY_MS*gDSP_Core_Speed_Hz/6000;
	tmrCfg.reload_period= 0; //not used for this case
	tmrCfg.pulseWidth= 3;
	Timer64_Init(&tmrCfg);

	//wait until the interrupt happen, which means the pulse has been generated
	while(0==uiTick)
		asm(" nop 5");

	puts("a pulse was generated on TIMO0\n");
}

/*use local timer (==DNUM of a core) to generate a clock on TIMO0,
interrupts are generated as well*/
void generate_clocks_by_timer()
{
	Timer64_Config tmrCfg;

	puts("clocks will be generated on TIMO0...");

	uiTick = 0;

	//select output on TIMO0 from local timer.
	gpBootCfgRegs->TOUTSEL = (DNUM*2)<<CSL_BOOTCFG_TOUTSEL_TOUTSEL0_SHIFT;

	/*configure the timer to generate clocks and interrupts*/
	tmrCfg.timer_num= DNUM;
	tmrCfg.timerMode= TIMER_PERIODIC_CLOCK;
	tmrCfg.period= (unsigned long long)CLOCK_PERIOD_MS*gDSP_Core_Speed_Hz/6000;
	tmrCfg.reload_period= 0; //not used for this case
	Timer64_Init(&tmrCfg);

	//wait until a number of interupts happen
	while(uiTick<NUM_CLOCKS_GENERATED*2)
		asm(" nop 5");
	Reset_Timer(DNUM); 	//stop the timer
	
	puts("clocks were generated on TIMO0\n");
}

/*source buffer for EDMA to reload timer registers*/
typedef struct  {
	Uint32 uiLowPeriod; 
	Uint32 uiINT_flag_low; 	//value for clearing interrupt flag
	Uint32 uiHighPeriod; 
	Uint32 uiINT_flag_high; //value for clearing interrupt flag
} TimerReloadBuf;

/*use timer DNUM to generate square waves on TIMO1,
interrupts are generated as well.
EDMA is used to reload period register*/
TimerReloadBuf reload_buf;
void generate_waves_by_timer()
{
	Timer64_Config tmrCfg;
	unsigned long long ullPeriod;
	Uint32 uiTimeNum;
	
	if(C6678_EVM == gDSP_board_type)
		uiTimeNum= 8;
	else
		uiTimeNum= 4;

	puts("Square waves will be generated on TIMO1...");

	uiTick = 0;

	//select output on TIMO1 from local timer.
	gpBootCfgRegs->TOUTSEL = (uiTimeNum*2)<<CSL_BOOTCFG_TOUTSEL_TOUTSEL1_SHIFT;

	ullPeriod= (unsigned long long)WAVE_PERIOD_MS*gDSP_Core_Speed_Hz/6000;
	reload_buf.uiLowPeriod= ullPeriod*WAVE_LOW_PERCENT/100;
	reload_buf.uiHighPeriod= ullPeriod - reload_buf.uiLowPeriod;
	reload_buf.uiINT_flag_low= TMR_INTCTLSTAT_EN_ALL_CLR_ALL;
	reload_buf.uiINT_flag_high= TMR_INTCTLSTAT_EN_ALL_CLR_ALL;

	/*setup EDMA to reload low period and high period valud continously,
	the EDMA is triggered by timer event(interrupt)*/
	EDMA_init();
	EDMA_channel_TC_cfg(1, 22, 3); 	//use TC3 for channel 22

	gpEDMA_CC_regs[1]->PARAMSET[22].OPT= 
		CSL_EDMA3_OPT_MAKE(CSL_EDMA3_ITCCH_DIS, 
			CSL_EDMA3_TCCH_DIS, 
			CSL_EDMA3_ITCINT_DIS, 
			CSL_EDMA3_TCINT_EN,
			22,
			CSL_EDMA3_TCC_NORMAL,
			CSL_EDMA3_FIFOWIDTH_NONE, 
			CSL_EDMA3_STATIC_DIS, 
			CSL_EDMA3_SYNC_AB, 
			CSL_EDMA3_ADDRMODE_INCR, 
			CSL_EDMA3_ADDRMODE_INCR);
	gpEDMA_CC_regs[1]->PARAMSET[22].SRC= GLOBAL_ADDR(&reload_buf);
	gpEDMA_CC_regs[1]->PARAMSET[22].A_B_CNT= CSL_EDMA3_CNT_MAKE(4, 2);
	gpEDMA_CC_regs[1]->PARAMSET[22].DST= (Uint32)&gpTimerRegs[uiTimeNum]->RELLO;
	gpEDMA_CC_regs[1]->PARAMSET[22].SRC_DST_BIDX= CSL_EDMA3_BIDX_MAKE(4, 16);
	gpEDMA_CC_regs[1]->PARAMSET[22].LINK_BCNTRLD= CSL_EDMA3_LINKBCNTRLD_MAKE(64*32, 2);
	gpEDMA_CC_regs[1]->PARAMSET[22].SRC_DST_CIDX= CSL_EDMA3_CIDX_MAKE(8, 0);
	gpEDMA_CC_regs[1]->PARAMSET[22].CCNT= 2;

	/*fill reload PaRAM*/
	gpEDMA_CC_regs[1]->PARAMSET[64].OPT= 
		CSL_EDMA3_OPT_MAKE(CSL_EDMA3_ITCCH_DIS, 
			CSL_EDMA3_TCCH_DIS, 
			CSL_EDMA3_ITCINT_DIS, 
			CSL_EDMA3_TCINT_EN,
			22,
			CSL_EDMA3_TCC_NORMAL,
			CSL_EDMA3_FIFOWIDTH_NONE, 
			CSL_EDMA3_STATIC_DIS, 
			CSL_EDMA3_SYNC_AB, 
			CSL_EDMA3_ADDRMODE_INCR, 
			CSL_EDMA3_ADDRMODE_INCR);
	gpEDMA_CC_regs[1]->PARAMSET[64].SRC= GLOBAL_ADDR(&reload_buf);
	gpEDMA_CC_regs[1]->PARAMSET[64].A_B_CNT= CSL_EDMA3_CNT_MAKE(4, 2);
	gpEDMA_CC_regs[1]->PARAMSET[64].DST= (Uint32)&gpTimerRegs[uiTimeNum]->RELLO;
	gpEDMA_CC_regs[1]->PARAMSET[64].SRC_DST_BIDX= CSL_EDMA3_BIDX_MAKE(4, 16);
	gpEDMA_CC_regs[1]->PARAMSET[64].LINK_BCNTRLD= CSL_EDMA3_LINKBCNTRLD_MAKE(64*32, 2);
	gpEDMA_CC_regs[1]->PARAMSET[64].SRC_DST_CIDX= CSL_EDMA3_CIDX_MAKE(8, 0);
	gpEDMA_CC_regs[1]->PARAMSET[64].CCNT= 2;

	/*clear event*/
	gpEDMA_CC_regs[1]->TPCC_ECR= 1<<22;
	/*enable event*/
	gpEDMA_CC_regs[1]->TPCC_EESR= 1<<22;
 

	/*configure the timer to generate clocks and interrupts*/
	tmrCfg.timer_num= uiTimeNum;
	tmrCfg.timerMode= TIMER_PERIODIC_WAVE;
	tmrCfg.period= reload_buf.uiLowPeriod;
	tmrCfg.reload_period= reload_buf.uiHighPeriod;
	Timer64_Init(&tmrCfg);

	//wait until a number of interupts happen
	while(uiTick<NUM_WAVES_GENERATED*2)
		asm(" nop 5");
	Reset_Timer(uiTimeNum); 	//stop the timer

	/*disable EDMA event*/
	gpEDMA_CC_regs[1]->TPCC_EECR= 1<<22;
	
	puts("Square waves were generated on TIMO1\n");
}

/*set local timer (==DNUM of a core) as watch dog timer,
service the watch-dog for sometime, 
after stop servicing watch-dog, let it trigger NMI*/
void watchdog_timer_test()
{
	int i;
	Uint32 timerCnt;
	Timer64_Config tmrCfg;

	//select output on TIMO0 from local timer.
	gpBootCfgRegs->TOUTSEL = (DNUM*2)<<CSL_BOOTCFG_TOUTSEL_TOUTSEL0_SHIFT;

	gpBootCfgRegs->RSTMUX[DNUM] = 
		(4<<CSL_BOOTCFG_RSTMUX0_RSTMUX_DELAY0_SHIFT)
		/*WD timer event trigger NMI*/
		|(WD_TRIGGER_NMI<<CSL_BOOTCFG_RSTMUX0_RSTMUX_OMODE0_SHIFT);

	puts("start watch-dog timer...");

	//configure the timer for watch-dog
	tmrCfg.timer_num= DNUM;
	tmrCfg.timerMode= TIMER_WATCH_DOG;
	tmrCfg.period= (unsigned long long)WATCH_DOG_PERIOD_MS*gDSP_Core_Speed_Hz/6000;
	tmrCfg.reload_period= 0; //not used for this case
	tmrCfg.pulseWidth= 3;
	Timer64_Init(&tmrCfg);

	//service the watch-dog for sometime, 
	for(i=1; i<=30; i++)
	{
		timerCnt= gpTimerRegs[DNUM]->CNTLO;
		Service_Watchdog(DNUM);
		printf("service watch-dog %d times, at time counter = %u\n", 
			i, timerCnt);
	}

	puts("stop servicing watch-dog, it will timeout and trigger NMI...\n");
}

void main()
{
	/*enable TSC, memory protection interrupts, EDC for internal RAM;
    clear cache; protect L1 as cache*/
	KeyStone_common_CPU_init();
	/*print device information. 
	Enable memory protection interrupts, EDC for MSMC RAM*/
	KeyStone_common_device_init();

	//enable exception handling
	KeyStone_Exception_cfg(TRUE);

    CACHE_setL1PSize(CACHE_L1_32KCACHE);
    CACHE_setL1DSize(CACHE_L1_32KCACHE);
    CACHE_setL2Size(CACHE_0KCACHE);

	if(C6678_EVM==gDSP_board_type)
	{
		//DSP core speed: 100*10/1=1000MHz
		KeyStone_main_PLL_init(100, 10, 1); 
	}
	else if(TCI6614_EVM==gDSP_board_type
		||DUAL_NYQUIST_EVM==gDSP_board_type
		||C6670_EVM==gDSP_board_type)
	{
		//DSP core speed: 122.88*236/29= 999.9889655MHz
		KeyStone_main_PLL_init(122.88, 236, 29);
	}
	else
	{
		puts("Unknown DSP board type!");
		return;
	}

	Timer_Interrupts_Init();

	generate_pulse_by_timer();
	generate_clocks_by_timer();
	generate_waves_by_timer();
	watchdog_timer_test();

	TSC_delay_ms(2*WATCH_DOG_PERIOD_MS);
	//while(1);
}

